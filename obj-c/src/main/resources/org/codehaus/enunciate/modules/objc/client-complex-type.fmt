[#ftl]

[#--template for the client-side complex type.--]
[#macro writeComplexTypeHeader type]
  [#assign typeName=nameForTypeDefinition(type)/]
#ifndef DEF_${typeName}_H
#define DEF_${typeName}_H

/**
 * ${type.docComment!"(no documentation provided)"?chop_linebreak?replace("\n", "\n * ")}
 */
@interface ${typeName} : [#if ((!type.baseObject) && (type.baseType.typeDefinition??))]${nameForTypeDefinition(type.baseType.typeDefinition)}[#else]NSObject[/#if][#if findRootElement(type)??] <EnunciateXML>[/#if]
{
  @private
  [#list type.attributes as attribute]
    [#if !isFacetExcluded(attribute)]
      [#if !accessorOverridesAnother(attribute)]
    ${classnameFor(attribute)} [#if !attribute.accessorType.primitive]*[/#if]_${clientSimpleName(attribute)};
      [/#if]
    [/#if]
  [/#list]
  [#if type.value??]
    [#if !isFacetExcluded(type.value)]
      [#if !accessorOverridesAnother(type.value)]
    ${classnameFor(type.value)} [#if !type.value.accessorType.primitive]*[/#if]_${clientSimpleName(type.value)};
      [/#if]
    [/#if]
  [#else]
    [#list type.elements as element]
      [#if !isFacetExcluded(element)]
        [#if !accessorOverridesAnother(element)]
    ${classnameFor(element)} [#if !element.accessorType.primitive]*[/#if]_${clientSimpleName(element)};
        [/#if]
      [/#if]
    [/#list]
  [/#if]
  [#if type.anyElement??]
    NSArray *_${clientSimpleName(type.anyElement)};
  [/#if]
  [#if type.hasAnyAttribute]
    NSArray *_otherAttributes;
  [/#if]
}
[#list type.attributes as attribute]
  [#if !isFacetExcluded(attribute)]
    [#if !accessorOverridesAnother(attribute)]

/**
 * ${(attribute.javaDoc.return!attribute.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (${classnameFor(attribute)}[#if !attribute.accessorType.primitive] *[/#if]) ${clientSimpleName(attribute)};

/**
 * ${(attribute.javaDoc.return!attribute.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (void) set${clientSimpleName(attribute)?cap_first}: (${classnameFor(attribute)}[#if !attribute.accessorType.primitive] *[/#if]) new${clientSimpleName(attribute)?cap_first};
      [#if attribute.referencesQNameEnum!false]

/**
 * Get the associated enum for ${clientSimpleName(attribute)}, if it's a known type.
 *
 * @return The known enum, or -1 if not known.
 */
- (${classnameFor(attribute.QNameEnumRef)}) known${clientSimpleName(attribute)?cap_first};

/**
 * Set the value of ${clientSimpleName(attribute)} using a known enumeration.
 *
 * @param new${clientSimpleName(attribute)?cap_first} The new value.
 */
- (void) setKnown${clientSimpleName(attribute)?cap_first}: (${classnameFor(attribute.QNameEnumRef)}) new${clientSimpleName(attribute)?cap_first};
      [/#if]
    [/#if]
  [/#if]
[/#list]
[#if type.value??]
  [#if !isFacetExcluded(type.value)]
    [#if !accessorOverridesAnother(type.value)]

/**
 * ${(type.value.javaDoc.return!type.value.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (${classnameFor(type.value)}[#if !type.value.accessorType.primitive] *[/#if]) ${clientSimpleName(type.value)};

/**
 * ${(type.value.javaDoc.return!type.value.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (void) set${clientSimpleName(type.value)?cap_first}: (${classnameFor(type.value)}[#if !type.value.accessorType.primitive] *[/#if]) new${clientSimpleName(type.value)?cap_first};
      [#if type.value.referencesQNameEnum!false]

/**
 * Get the associated enum for ${clientSimpleName(type.value)}, if it's a known type.
 *
 * @return The known enum, or -1 if not known.
 */
- (${classnameFor(type.value.QNameEnumRef)}) known${clientSimpleName(type.value)?cap_first};

/**
 * Set the value of ${clientSimpleName(type.value)} using a known enumeration.
 *
 * @param new${clientSimpleName(type.value)?cap_first} The new value.
 */
- (void) setKnown${clientSimpleName(type.value)?cap_first}: (${classnameFor(type.value.QNameEnumRef)}) new${clientSimpleName(type.value)?cap_first};
      [/#if]
    [/#if]
  [/#if]
[#else]
  [#list type.elements as element]
    [#if !isFacetExcluded(element)]
      [#if !accessorOverridesAnother(element)]

/**
 * ${(element.javaDoc.return!element.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (${classnameFor(element)}[#if !element.accessorType.primitive] *[/#if]) ${clientSimpleName(element)};

/**
 * ${(element.javaDoc.return!element.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (void) set${clientSimpleName(element)?cap_first}: (${classnameFor(element)}[#if !element.accessorType.primitive] *[/#if]) new${clientSimpleName(element)?cap_first};
        [#if element.referencesQNameEnum!false]

/**
 * Get the associated enum for ${clientSimpleName(element)}, if it's a known type.
 *
 * @return The known enum, or -1 if not known.
 */
- (${classnameFor(element.QNameEnumRef)}) known${clientSimpleName(element)?cap_first};

/**
 * Set the value of ${clientSimpleName(element)} using a known enumeration.
 *
 * @param new${clientSimpleName(element)?cap_first} The new value.
 */
- (void) setKnown${clientSimpleName(element)?cap_first}: (${classnameFor(element.QNameEnumRef)}) new${clientSimpleName(element)?cap_first};
        [/#if]
      [/#if]
    [/#if]
  [/#list]
[/#if]
[#if type.anyElement??]

/**
 * ${(type.anyElement.javaDoc.return!type.anyElement.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (NSArray *) ${clientSimpleName(type.anyElement)};

/**
 * ${(type.anyElement.javaDoc.return!type.anyElement.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (void) set${clientSimpleName(type.anyElement)?cap_first}: (NSArray *) new${clientSimpleName(type.anyElement)?cap_first};
[/#if]
[#if type.hasAnyAttribute]

/**
 * Other attributes applicable to ${typeName}.
 *
 * Contains instances of JAXBBasicXMLNode.
  [#if type.anyAttributeQNameEnumRef??]
 *
 * See ${classnameFor(type.anyAttributeQNameEnumRef)} for an enumeration of known attributes.
  [/#if]
 */
- (NSArray *) otherAttributes;

/**
 * Other attributes applicable to ${typeName}.
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (void) setOtherAttributes: (NSArray *) otherAttributes;
[/#if]
@end /* interface ${typeName} */

#endif /* DEF_${typeName}_H */
[/#macro]



[#macro writeComplexTypeImpl type]
  [#assign typeName=nameForTypeDefinition(type)/]
#ifndef DEF_${typeName}_M
#define DEF_${typeName}_M

/**
 * ${type.docComment!"(no documentation provided)"?chop_linebreak?replace("\n", "\n * ")}
 */
@implementation ${typeName}
[#list type.attributes as attribute]
  [#if !isFacetExcluded(attribute)]
    [#if !accessorOverridesAnother(attribute)]

/**
 * ${(attribute.javaDoc.return!attribute.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (${classnameFor(attribute)}[#if !attribute.accessorType.primitive] *[/#if]) ${clientSimpleName(attribute)}
{
  return _${clientSimpleName(attribute)};
}

/**
 * ${(attribute.javaDoc.return!attribute.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (void) set${clientSimpleName(attribute)?cap_first}: (${classnameFor(attribute)}[#if !attribute.accessorType.primitive] *[/#if]) new${clientSimpleName(attribute)?cap_first}
{
    [#if !attribute.accessorType.primitive]
      [#if functionIdentifierFor(attribute)??]
  if (_${clientSimpleName(attribute)} != NULL) {
    free(_${clientSimpleName(attribute)});
  }
      [#else]
  [new${clientSimpleName(attribute)?cap_first} retain];
  [_${clientSimpleName(attribute)} release];
      [/#if]
    [/#if]
  _${clientSimpleName(attribute)} = new${clientSimpleName(attribute)?cap_first};
}
      [#if attribute.referencesQNameEnum!false]

/**
 * Get the associated enum for ${clientSimpleName(attribute)}, if it's a known type.
 *
 * @return The known enum, or -1 if not known.
 */
- (${classnameFor(attribute.QNameEnumRef)}) known${clientSimpleName(attribute)?cap_first}
{
  return getKnown${functionIdentifierFor(attribute.QNameEnumRef)}([self ${clientSimpleName(attribute)}]);
}

/**
 * Set the value of ${clientSimpleName(attribute)} using a known enumeration.
 *
 * @param new${clientSimpleName(attribute)?cap_first} The new value.
 */
- (void) setKnown${clientSimpleName(attribute)?cap_first}: (${classnameFor(attribute.QNameEnumRef)}) new${clientSimpleName(attribute)?cap_first}
{
  ${classnameFor(attribute)} *qname = convertKnown${functionIdentifierFor(attribute.QNameEnumRef)}(new${clientSimpleName(attribute)?cap_first});
  if (qname) {
    [self set${clientSimpleName(attribute)?cap_first}: qname];
  }
  else {
    [NSException raise: @"UnknownQNameEnum"
                 format: @"Not a known QName enum."];
  }
}
      [/#if]
    [/#if]
  [/#if]
[/#list]
[#if type.value??]
  [#if !isFacetExcluded(type.vale)]
    [#if !accessorOverridesAnother(type.value)]

/**
 * ${(type.value.javaDoc.return!type.value.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (${classnameFor(type.value)}[#if !type.value.accessorType.primitive] *[/#if]) ${clientSimpleName(type.value)}
{
  return _${clientSimpleName(type.value)};
}

/**
 * ${(type.value.javaDoc.return!type.value.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (void) set${clientSimpleName(type.value)?cap_first}: (${classnameFor(type.value)}[#if !type.value.accessorType.primitive] *[/#if]) new${clientSimpleName(type.value)?cap_first}
{
    [#if !type.value.accessorType.primitive]
      [#if functionIdentifierFor(type.value)??]
  if (_${clientSimpleName(type.value)} != NULL) {
    free(_${clientSimpleName(type.value)});
  }
      [#else]
  [new${clientSimpleName(type.value)?cap_first} retain];
  [_${clientSimpleName(type.value)} release];
      [/#if]
    [/#if]
  _${clientSimpleName(type.value)} = new${clientSimpleName(type.value)?cap_first};
}
      [#if type.value.referencesQNameEnum!false]

/**
 * Get the associated enum for ${clientSimpleName(type.value)}, if it's a known type.
 *
 * @return The known enum, or -1 if not known.
 */
- (${classnameFor(type.value.QNameEnumRef)}) known${clientSimpleName(type.value)?cap_first}
{
  return getKnown${functionIdentifierFor(type.value.QNameEnumRef)}([self ${clientSimpleName(type.value)}]);
}

/**
 * Set the value of ${clientSimpleName(type.value)} using a known enumeration.
 *
 * @param new${clientSimpleName(type.value)?cap_first} The new value.
 */
- (void) setKnown${clientSimpleName(type.value)?cap_first}: (${classnameFor(type.value.QNameEnumRef)}) new${clientSimpleName(type.value)?cap_first}
{
  ${classnameFor(type.value)} *qname = convertKnown${functionIdentifierFor(type.value.QNameEnumRef)}(new${clientSimpleName(type.value)?cap_first});
  if (qname) {
    [self set${clientSimpleName(type.value)?cap_first}: qname];
  }
  else {
    [NSException raise: @"UnknownQNameEnum"
                 format: @"Not a known QName enum."];
  }
}
      [/#if]
    [/#if]
  [/#if]
[#else]
  [#list type.elements as element]
    [#if !isFacetExcluded(element)]
      [#if !accessorOverridesAnother(element)]

/**
 * ${(element.javaDoc.return!element.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (${classnameFor(element)}[#if !element.accessorType.primitive] *[/#if]) ${clientSimpleName(element)}
{
  return _${clientSimpleName(element)};
}

/**
 * ${(element.javaDoc.return!element.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 */
- (void) set${clientSimpleName(element)?cap_first}: (${classnameFor(element)}[#if !element.accessorType.primitive] *[/#if]) new${clientSimpleName(element)?cap_first}
{
    [#if !element.accessorType.primitive]
      [#if functionIdentifierFor(element)??]
  if (_${clientSimpleName(element)} != NULL) {
    free(_${clientSimpleName(element)});
  }
      [#else]
  [new${clientSimpleName(element)?cap_first} retain];
  [_${clientSimpleName(element)} release];
      [/#if]
    [/#if]
  _${clientSimpleName(element)} = new${clientSimpleName(element)?cap_first};
}
        [#if element.referencesQNameEnum!false]

/**
 * Get the associated enum for ${clientSimpleName(element)}, if it's a known type.
 *
 * @return The known enum, or -1 if not known.
 */
- (${classnameFor(element.QNameEnumRef)}) known${clientSimpleName(element)?cap_first}
{
  return getKnown${functionIdentifierFor(element.QNameEnumRef)}([self ${clientSimpleName(element)}]);
}

/**
 * Set the value of ${clientSimpleName(element)} using a known enumeration.
 *
 * @param new${clientSimpleName(element)?cap_first} The new value.
 */
- (void) setKnown${clientSimpleName(element)?cap_first}: (${classnameFor(element.QNameEnumRef)}) new${clientSimpleName(element)?cap_first}
{
  ${classnameFor(element)} *qname = convertKnown${functionIdentifierFor(element.QNameEnumRef)}(new${clientSimpleName(element)?cap_first});
  if (qname) {
    [self set${clientSimpleName(element)?cap_first}: qname];
  }
  else {
    [NSException raise: @"UnknownQNameEnum"
                 format: @"Not a known QName enum."];
  }
}
        [/#if]
      [/#if]
    [/#if]
  [/#list]
[/#if]
[#if type.anyElement??]

/**
 * ${(type.anyElement.javaDoc.return!type.anyElement.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (NSArray *) ${clientSimpleName(type.anyElement)}
{
  return _${clientSimpleName(type.anyElement)};
}

/**
 * ${(type.anyElement.javaDoc.return!type.anyElement.docValue!"(no documentation provided)")?chop_linebreak?replace("\n", "\n * ")}
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (void) set${clientSimpleName(type.anyElement)?cap_first}: (NSArray *) new${clientSimpleName(type.anyElement)?cap_first}
{
  [new${clientSimpleName(type.anyElement)?cap_first} retain];
  [_${clientSimpleName(type.anyElement)} release];
  _${clientSimpleName(type.anyElement)} = new${clientSimpleName(type.anyElement)?cap_first};
}
[/#if]
[#if type.hasAnyAttribute]

/**
 * Other attributes applicable to ${typeName}.
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (NSArray *) otherAttributes
{
  return _otherAttributes;
}

/**
 * Other attributes applicable to ${typeName}.
 *
 * Contains instances of JAXBBasicXMLNode.
 */
- (void) setOtherAttributes: (NSArray *) otherAttributes
{
  [otherAttributes retain];
  [_otherAttributes release];
  _otherAttributes = otherAttributes;
}
[/#if]

- (void) dealloc
{
[#list type.attributes as attribute]
  [#if !isFacetExcluded(attribute)]
    [#if !accessorOverridesAnother(attribute)]
      [#if !attribute.accessorType.primitive]
        [#if functionIdentifierFor(attribute)??]
  [self set${clientSimpleName(attribute)?cap_first}: NULL];
        [#else]
  [self set${clientSimpleName(attribute)?cap_first}: nil];
        [/#if]
      [/#if]
    [/#if]
  [/#if]
[/#list]
[#if type.value??]
  [#if !isFacetExcluded(type.value)]
    [#if !accessorOverridesAnother(type.value)]
      [#if !type.value.accessorType.primitive]
        [#if functionIdentifierFor(type.value)??]
  [self set${clientSimpleName(type.value)?cap_first}: NULL];
        [#else]
  [self set${clientSimpleName(type.value)?cap_first}: nil];
        [/#if]
      [/#if]
    [/#if]
  [/#if]
[#else]
  [#list type.elements as element]
    [#if !isFacetExcluded(element)]
      [#if !accessorOverridesAnother(element)]
        [#if !element.accessorType.primitive]
          [#if functionIdentifierFor(element)??]
  [self set${clientSimpleName(element)?cap_first}: NULL];
          [#else]
  [self set${clientSimpleName(element)?cap_first}: nil];
          [/#if]
        [/#if]
      [/#if]
    [/#if]
  [/#list]
[/#if]
[#if type.anyElement??]
  [self set${clientSimpleName(type.anyElement)?cap_first}: nil];
[/#if]
[#if type.hasAnyAttribute]
  [self setOtherAttributes: nil];
[/#if]
  [super dealloc];
}
[#if findRootElement(type)??]
  [#assign rootElement=findRootElement(type)/]

//documentation inherited.
+ (id<EnunciateXML>) readFromXML: (NSData *) xml
{
  ${typeName} *_${typeName?uncap_first};
  xmlTextReaderPtr reader = xmlReaderForMemory([xml bytes], [xml length], NULL, NULL, 0);
  if (reader == NULL) {
    [NSException raise: @"XMLReadError"
                 format: @"Error instantiating an XML reader."];
    return nil;
  }

  _${typeName?uncap_first} = (${typeName} *) [${typeName} readXMLElement: reader];
  xmlFreeTextReader(reader); //free the reader
  return _${typeName?uncap_first};
}

//documentation inherited.
- (NSData *) writeToXML
{
  xmlBufferPtr buf;
  xmlTextWriterPtr writer;
  int rc;
  NSData *data;

  buf = xmlBufferCreate();
  if (buf == NULL) {
    [NSException raise: @"XMLWriteError"
                 format: @"Error creating an XML buffer."];
    return nil;
  }

  writer = xmlNewTextWriterMemory(buf, 0);
  if (writer == NULL) {
    xmlBufferFree(buf);
    [NSException raise: @"XMLWriteError"
                 format: @"Error creating an XML writer."];
    return nil;
  }

  rc = xmlTextWriterStartDocument(writer, NULL, "utf-8", NULL);
  if (rc < 0) {
    xmlFreeTextWriter(writer);
    xmlBufferFree(buf);
    [NSException raise: @"XMLWriteError"
                 format: @"Error writing XML start document."];
    return nil;
  }

  NS_DURING
  {
    [self writeXMLElement: writer];
  }
  NS_HANDLER
  {
    xmlFreeTextWriter(writer);
    xmlBufferFree(buf);
    [localException raise];
  }
  NS_ENDHANDLER

  rc = xmlTextWriterEndDocument(writer);
  if (rc < 0) {
    xmlFreeTextWriter(writer);
    xmlBufferFree(buf);
    [NSException raise: @"XMLWriteError"
                 format: @"Error writing XML end document."];
    return nil;
  }

  xmlFreeTextWriter(writer);
  data = [NSData dataWithBytes: buf->content length: buf->use];
  xmlBufferFree(buf);
  return data;
}
[/#if]
@end /* implementation ${typeName} */

/**
 * Internal, private interface for JAXB reading and writing.
 */
@interface ${typeName} (JAXB) <JAXBReading, JAXBWriting, JAXBType[#if findRootElement(type)??], JAXBElement[/#if]>

@end /*interface ${typeName} (JAXB)*/

/**
 * Internal, private implementation for JAXB reading and writing.
 */
@implementation ${typeName} (JAXB)

/**
 * Read an instance of ${typeName} from an XML reader.
 *
 * @param reader The reader.
 * @return An instance of ${typeName} defined by the XML reader.
 */
+ (id<JAXBType>) readXMLType: (xmlTextReaderPtr) reader
{
  ${typeName} *_${typeName?uncap_first} = [[${typeName} alloc] init];
  NS_DURING
  {
    [_${typeName?uncap_first} initWithReader: reader];
  }
  NS_HANDLER
  {
    _${typeName?uncap_first} = nil;
    [localException raise];
  }
  NS_ENDHANDLER

  [_${typeName?uncap_first} autorelease];
  return _${typeName?uncap_first};
}

/**
 * Initialize this instance of ${typeName} according to
 * the XML being read from the reader.
 *
 * @param reader The reader.
 */
- (id) initWithReader: (xmlTextReaderPtr) reader
{
  return [super initWithReader: reader];
}

/**
 * Write the XML for this instance of ${typeName} to the writer.
 * Note that since we're only writing the XML type,
 * No start/end element will be written.
 *
 * @param reader The reader.
 */
- (void) writeXMLType: (xmlTextWriterPtr) writer
{
  [super writeXMLType:writer];
}
  [#if findRootElement(type)??]
    [#assign rootElement=findRootElement(type)/]

/**
 * Reads a ${typeName} from an XML reader. The element to be read is
 * "[#if ((rootElement.namespace??) && (rootElement.namespace != ""))]{${rootElement.namespace}}[/#if]${rootElement.name}".
 *
 * @param reader The XML reader.
 * @return The ${typeName}.
 */
+ (id<JAXBElement>) readXMLElement: (xmlTextReaderPtr) reader {
  int status;
  ${typeName} *_${type.clientSimpleName?uncap_first} = nil;

  if (xmlTextReaderNodeType(reader) != XML_READER_TYPE_ELEMENT) {
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
    if (status < 1) {
      [NSException raise: @"XMLReadError"
                   format: @"Error advancing the reader to start element [#if ((rootElement.namespace??) && (rootElement.namespace != ""))]{${rootElement.namespace}}[/#if]${rootElement.name}."];
    }
  }

  if (xmlStrcmp(BAD_CAST "${rootElement.name}", xmlTextReaderConstLocalName(reader)) == 0
      && [#if ((rootElement.namespace??) && (rootElement.namespace != ""))]xmlStrcmp(BAD_CAST "${rootElement.namespace}", xmlTextReaderConstNamespaceUri(reader)) == 0[#else]xmlTextReaderConstNamespaceUri(reader) == NULL[/#if]) {
#if DEBUG_ENUNCIATE > 1
    NSLog(@"Attempting to read root element {${rootElement.namespace!""}}${rootElement.name}.");
#endif
    _${type.clientSimpleName?uncap_first} = (${typeName} *)[${typeName} readXMLType: reader];
#if DEBUG_ENUNCIATE > 1
    NSLog(@"Successfully read root element {${rootElement.namespace!""}}${rootElement.name}.");
#endif
  }
  else {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      [NSException raise: @"XMLReadError"
                   format: @"Unable to read ${typeName}. Expected element [#if ((rootElement.namespace??) && (rootElement.namespace != ""))]{${rootElement.namespace}}[/#if]${rootElement.name}. Current element: {}%s", xmlTextReaderConstLocalName(reader)];
    }
    else {
      [NSException raise: @"XMLReadError"
                   format: @"Unable to read ${typeName}. Expected element [#if ((rootElement.namespace??) && (rootElement.namespace != ""))]{${rootElement.namespace}}[/#if]${rootElement.name}. Current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader)];
    }
  }

  return _${type.clientSimpleName?uncap_first};
}

/**
 * Writes this ${typeName} to XML under element name "[#if ((rootElement.namespace??) && (rootElement.namespace != ""))]{${rootElement.namespace}}[/#if]${rootElement.name}".
 * The namespace declarations for the element will be written.
 *
 * @param writer The XML writer.
 * @param _${type.clientSimpleName?uncap_first} The ${type.clientSimpleName} to write.
 * @return 1 if successful, 0 otherwise.
 */
- (void) writeXMLElement: (xmlTextWriterPtr) writer
{
  [self writeXMLElement: writer writeNamespaces: YES];
}

/**
 * Writes this ${typeName} to an XML writer.
 *
 * @param writer The writer.
 * @param writeNs Whether to write the namespaces for this element to the xml writer.
 */
- (void) writeXMLElement: (xmlTextWriterPtr) writer writeNamespaces: (BOOL) writeNs
{
  int rc = xmlTextWriterStartElementNS(writer, [#if ((rootElement.namespace??) && (rootElement.namespace != ""))]BAD_CAST "${prefix(rootElement.namespace)}"[#else]NULL[/#if], BAD_CAST "${rootElement.name}", NULL);
  if (rc < 0) {
    [NSException raise: @"XMLWriteError"
                 format: @"Error writing start element {${rootElement.namespace!""}}${rootElement.name}. XML writer status: %i\n", rc];
  }
    [#assign localReferencedNamespaces=referencedNamespaces(rootElement)/]
    [#if localReferencedNamespaces?size > 0]

  if (writeNs) {
#if DEBUG_ENUNCIATE > 1
    NSLog(@"writing namespaces for start element {${rootElement.namespace!""}}${rootElement.name}...");
#endif
      [#list localReferencedNamespaces as referencedNamespace]
        [#if ((referencedNamespace??) && (referencedNamespace?length > 0))]

    rc = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:${prefix(referencedNamespace)}", BAD_CAST "${referencedNamespace}");
    if (rc < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing attribute 'xmlns:${prefix(referencedNamespace)}' on '{${rootElement.namespace!""}}${rootElement.name}'. XML writer status: %i\n", rc];
    }
       [/#if]
     [/#list]
#if DEBUG_ENUNCIATE > 1
    NSLog(@"successfully wrote namespaces for start element {${rootElement.namespace!""}}${rootElement.name}...");
#endif
  }
    [/#if]

#if DEBUG_ENUNCIATE > 1
  NSLog(@"writing type {${type.qname.namespaceURI}}${type.qname.localPart} for root element {${rootElement.namespace!""}}${rootElement.name}...");
#endif
  [self writeXMLType: writer];
#if DEBUG_ENUNCIATE > 1
  NSLog(@"successfully wrote type {${type.qname.namespaceURI}}${type.qname.localPart} for root element {${rootElement.namespace!""}}${rootElement.name}...");
#endif
  rc = xmlTextWriterEndElement(writer);
  if (rc < 0) {
    [NSException raise: @"XMLWriteError"
                 format: @"Error writing end element {${rootElement.namespace!""}}${rootElement.name}. XML writer status: %i\n", rc];
  }
}
  [/#if]

//documentation inherited.
- (BOOL) readJAXBAttribute: (xmlTextReaderPtr) reader
{
  void *_child_accessor;

  if ([super readJAXBAttribute: reader]) {
    return YES;
  }
  [#list type.attributes as attribute]
    [#if !isFacetExcluded(attribute)]
      [#if !accessorOverridesAnother(attribute)]

  if ((xmlStrcmp(BAD_CAST "${attribute.name}", xmlTextReaderConstLocalName(reader)) == 0) && ([#if ((attribute.namespace??) && (attribute.namespace != ""))]xmlStrcmp(BAD_CAST "${attribute.namespace}", xmlTextReaderConstNamespaceUri(reader)) == 0[#else]xmlTextReaderConstNamespaceUri(reader) == NULL[/#if])) {
#if DEBUG_ENUNCIATE > 1
    NSLog(@"Attempting to read attribute {${attribute.namespace!""}}${attribute.name}...");
#endif
      [#if functionIdentifierFor(attribute)??]
    _child_accessor = xmlTextReaderRead${functionIdentifierFor(attribute)}Type(reader);
    if (_child_accessor == NULL) {
      //panic: unable to read the attribute value for some reason.
      [NSException raise: @"XMLReadError"
                   format: @"Error reading attribute {${attribute.namespace!""}}${attribute.name}."];
    }
    [self set${clientSimpleName(attribute)?cap_first}: [#if attribute.accessorType.primitive]*[/#if]((${classnameFor(attribute)}*) _child_accessor)];
        [#if attribute.accessorType.primitive]
    free(_child_accessor);
        [/#if]
      [#else]
    [self set${clientSimpleName(attribute)?cap_first}: (${classnameFor(attribute)}*) [${classnameFor(attribute)} readXMLType: reader]];
      [/#if]
#if DEBUG_ENUNCIATE > 1
    NSLog(@"successfully read attribute {${attribute.namespace!""}}${attribute.name}...");
#endif
    return YES;
  }
      [/#if]
    [/#if]
  [/#list]

  return NO;
}
[#if type.value??]
  [#if !isFacetExcluded(type.value)]
    [#if !accessorOverridesAnother(type.value)]

//documentation inherited.
- (BOOL) readJAXBValue: (xmlTextReaderPtr) reader
{
      [#if functionIdentifierFor(type.value)??]
  void *_child_accessor;
      [/#if]

#if DEBUG_ENUNCIATE > 1
  NSLog(@"Attempting to read element value...");
#endif
  if (xmlTextReaderIsEmptyElement(reader) == 0) {
      [#if functionIdentifierFor(type.value)??]
    _child_accessor = xmlTextReaderRead${functionIdentifierFor(type.value)?cap_first}Type(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
      [NSException raise: @"XMLReadError"
                   format: @"Error reading element value."];
    }
    [self set${clientSimpleName(type.value)?cap_first}: [#if type.value.accessorType.primitive]*[/#if]((${classnameFor(type.value)}*) _child_accessor)];
        [#if type.value.accessorType.primitive]
    free(_child_accessor);
        [/#if]
      [#else]
    [self set${clientSimpleName(type.value)?cap_first}: (${classnameFor(type.value)} *) [${classnameFor(type.value)} readXMLType: reader]];
      [/#if]
  }
      [#if type.value.accessorType.isInstanceOf("java.lang.String")]
  [#--special case for string accessors (empty string)--]
  else {
    [self set${clientSimpleName(type.value)?cap_first}: @""];
  }
      [/#if]
#if DEBUG_ENUNCIATE > 1
  NSLog(@"successfully read element value...");
#endif

  return YES;
}
    [/#if]
  [/#if]
//documentation inherited.
- (BOOL) readJAXBChildElement: (xmlTextReaderPtr) reader
{
  return [super readJAXBChildElement: reader];
}
[#else]

//documentation inherited.
- (BOOL) readJAXBValue: (xmlTextReaderPtr) reader
{
  return [super readJAXBValue: reader];
}

//documentation inherited.
- (BOOL) readJAXBChildElement: (xmlTextReaderPtr) reader
{
  id __child;
  void *_child_accessor;
  int status, depth;

  if ([super readJAXBChildElement: reader]) {
    return YES;
  }
  [#list type.elements as element]
    [#if !isFacetExcluded(element)]
      [#if !accessorOverridesAnother(element)]
        [#if functionIdentifierFor(element)??]

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "${element.name}", xmlTextReaderConstLocalName(reader)) == 0
    && [#if ((element.namespace??) && (element.namespace != ""))]xmlStrcmp(BAD_CAST "${element.namespace}", xmlTextReaderConstNamespaceUri(reader)) == 0[#else]xmlTextReaderConstNamespaceUri(reader) == NULL[/#if]) {

    _child_accessor = xmlTextReaderRead${functionIdentifierFor(element)?cap_first}Type(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
      [NSException raise: @"XMLReadError"
                   format: @"Error reading element value."];
    }
    [self set${clientSimpleName(element)?cap_first}: [#if element.accessorType.primitive]*[/#if]((${classnameFor(element)}*) _child_accessor)];
          [#if element.accessorType.primitive]
    free(_child_accessor);
          [/#if]
    return YES;
  }
        [#else]
          [#if element.wrapped]
  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "${element.wrapperName}", xmlTextReaderConstLocalName(reader)) == 0
    && [#if ((element.wrapperNamespace??) && (element.wrapperNamespace != ""))]xmlStrcmp(BAD_CAST "${element.wrapperNamespace}", xmlTextReaderConstNamespaceUri(reader)) == 0[#else]xmlTextReaderConstNamespaceUri(reader) == NULL[/#if]) {

    if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
      NSLog(@"Unwrapping wrapper element {${element.wrapperNamespace!""}}${element.wrapperName}...");
#endif
      //start wrapper element "{${element.wrapperNamespace!""}}${element.wrapperName}"
      depth = xmlTextReaderDepth(reader);
      status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      while (xmlTextReaderDepth(reader) > depth) {
        if (status < 1) {
          //panic: XML read error.
          [NSException raise: @"XMLReadError"
                       format: @"Failure to advance to next wrapped child element."];
        }
          [/#if]
          [#list element.choices as choice]
  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "${choice.name}", xmlTextReaderConstLocalName(reader)) == 0
    && [#if ((choice.namespace??) && (choice.namespace != ""))]xmlStrcmp(BAD_CAST "${choice.namespace}", xmlTextReaderConstNamespaceUri(reader)) == 0[#else]xmlTextReaderConstNamespaceUri(reader) == NULL[/#if]) {

            [#if choice.nillable!false]
    status = 1;
    if (xmlTextReaderMoveToAttributeNs(reader, BAD_CAST "nil", BAD_CAST "http://www.w3.org/2001/XMLSchema-instance")) {
      if (xmlStrcmp(BAD_CAST "true", xmlTextReaderConstValue(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
        NSLog(@"Choice {${choice.namespace!""}}${choice.name} was nil according to the xsi:nil attribute.");
#endif
              [#if element.collectionType]
        __child = [NSNull null];
              [#else]
        __child = nil;
              [/#if]
        status = 0;
      }
    }

    xmlTextReaderMoveToElement(reader); //move back to the element
    if (status) { //if not "nil"...
            [/#if]
#if DEBUG_ENUNCIATE > 1
    NSLog(@"Attempting to read choice {${choice.namespace!""}}${choice.name} of [#if choice.ref??]element {${choice.ref.namespaceURI}}${choice.ref.localPart}[#else]type {${choice.baseType.qname.namespaceURI}}${choice.baseType.qname.localPart}[/#if].");
#endif
            [#if choice.ref??]
    __child = [${classnameFor(choice)} readXMLElement: reader];
            [#elseif choice.collectionType]

              [#if functionIdentifierFor(choice.collectionItemType)??]
    _child_accessor = xmlTextReaderRead${functionIdentifierFor(choice.collectionItemType)?cap_first}Type(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
      [NSException raise: @"XMLReadError"
                   format: @"Error reading element value."];
    }
    __child = [NSValue value: _child_accessor withObjCType: @encode(${classnameFor(choice.collectionItemType)})];
               [#else]
                  [#if element.wrapped]
    if(xmlTextReaderIsEmptyElement(reader) != 0){
      __child = [[${classnameFor(choice.collectionItemType)} alloc] init];
      xmlTextReaderAdvanceToNextStartOrEndElement(reader);
    }else{
      __child = [${classnameFor(choice.collectionItemType)} readXMLType: reader];
    }
                  [#else]
     __child = [${classnameFor(choice.collectionItemType)} readXMLType: reader];
                  [/#if]
               [/#if]
            [#else]
    __child = [${classnameFor(choice)} readXMLType: reader];
            [/#if]
#if DEBUG_ENUNCIATE > 1
    NSLog(@"successfully read choice {${choice.namespace!""}}${choice.name} of [#if choice.ref??]element {${choice.ref.namespaceURI}}${choice.ref.localPart}[#else]type {${choice.baseType.qname.namespaceURI}}${choice.baseType.qname.localPart}[/#if].");
#endif
            [#if choice.nillable!false]
    } //end "if not nil" clause
    else if (xmlTextReaderIsEmptyElement(reader) == 0) {
      //if it's not the empty element, skip it because it's nil.
      xmlTextReaderSkipElement(reader);
    }
            [/#if]

            [#if element.collectionType]
    if ([self ${clientSimpleName(element)}]) {
      [self set${clientSimpleName(element)?cap_first}: [[self ${clientSimpleName(element)}] arrayByAddingObject: __child]];
    }
    else {
      [self set${clientSimpleName(element)?cap_first}: [NSArray arrayWithObject: __child]];
    }
            [#else]
    [self set${clientSimpleName(element)?cap_first}: __child];
            [/#if]
            [#if element.wrapped]
    continue; //continue "while in wrapper element" loop
            [#else]
    return YES;
            [/#if]
  } //end "if choice"
          [/#list]

          [#if element.wrapped]
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
#if DEBUG_ENUNCIATE > 1
        NSLog(@"successfully unwrapped wrapper element {${element.wrapperNamespace!""}}${element.wrapperName}...");
#endif
      } // end "while in wrapper element" loop

      if (status < 1) {
        //panic: XML read error.
        [NSException raise: @"XMLReadError"
                     format: @"Failure to advance to end wrapper element."];
      }
    } //end "if empty element" clause
    else {
            [#if element.wrapperNillable]
      //we've got an empty wrapper element; see if it's nil.
      if (xmlTextReaderMoveToAttributeNs(reader, BAD_CAST "nil", BAD_CAST "http://www.w3.org/2001/XMLSchema-instance")) {
        if (xmlStrcmp(BAD_CAST "true", xmlTextReaderConstValue(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
          NSLog(@"wrapper {${element.wrapperNamespace!""}}${element.wrapperName} was nil according to the xsi:nil attribute.");
#endif
          __child = nil;
        }
        else {
          __child = [NSArray array];
        }
      }
      else {
        __child = [NSArray array];
      }
      xmlTextReaderMoveToElement(reader); //move back to the element
            [#else]
      __child = [NSArray array];
            [/#if]
      [self set${clientSimpleName(element)?cap_first}: (NSArray*) __child];
    }

    return YES;
  } // end "if wrapper element" clause
          [/#if]
        [/#if]
      [/#if]
    [/#if]
  [/#list]

  return NO;
}
[/#if]
[#if type.anyElement??]

//documentation inherited.
- (int) readUnknownJAXBChildElement: (xmlTextReaderPtr) reader
{
  JAXBBasicXMLNode *node = (JAXBBasicXMLNode *) [JAXBBasicXMLNode readXMLType: reader];
  if ([self ${clientSimpleName(type.anyElement)}]) {
    [self set${clientSimpleName(type.anyElement)?cap_first}: [[self ${clientSimpleName(type.anyElement)}] arrayByAddingObject: node]];
  }
  else {
    [self set${clientSimpleName(type.anyElement)?cap_first}: [NSArray arrayWithObject: node]];
  }
  return 1;
}
[#else]

//documentation inherited.
- (int) readUnknownJAXBChildElement: (xmlTextReaderPtr) reader
{
  return [super readUnknownJAXBChildElement: reader];
}
[/#if]
[#if type.hasAnyAttribute]

//documentation inherited.
- (void) readUnknownJAXBAttribute: (xmlTextReaderPtr) reader
{
  JAXBBasicXMLNode *node = (JAXBBasicXMLNode *) [JAXBBasicXMLNode readXMLType: reader];
  if ([self otherAttributes]) {
    [self setOtherAttributes: [[self otherAttributes] arrayByAddingObject: node]];
  }
  else {
    [self setOtherAttributes: [NSArray arrayWithObject: node]];
  }
}
[#else]

//documentation inherited.
- (void) readUnknownJAXBAttribute: (xmlTextReaderPtr) reader
{
  [super readUnknownJAXBAttribute: reader];
}
[/#if]

//documentation inherited.
- (void) writeJAXBAttributes: (xmlTextWriterPtr) writer
{
  int status;
[#if type.hasAnyAttribute]
  JAXBBasicXMLNode *__node;
  NSEnumerator *__enumerator;
[/#if]

  [super writeJAXBAttributes: writer];

[#list type.attributes as attribute]
  [#if !isFacetExcluded(attribute)]
    [#if !accessorOverridesAnother(attribute)]
      [#if attribute.accessorType.primitive]
  if (YES) { //always write the primitive attributes...
      [#elseif functionIdentifierFor(attribute)??]
  if ([self ${clientSimpleName(attribute)}] != NULL) {
      [#else]
  if ([self ${clientSimpleName(attribute)}]) {
      [/#if]
      [#if attribute.QNameType!false]
    if (([[[self ${clientSimpleName(attribute)}] prefix] length] == 0) &&
       ([[[self ${clientSimpleName(attribute)}] namespaceURI] length] > 0)) {
      status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:${attribute.name}NS", BAD_CAST [[[self ${clientSimpleName(attribute)}] namespaceURI] UTF8String]);
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing namespace attribute xmlns:${attribute.name}NS."];
      }

      [[self ${clientSimpleName(attribute)}] setPrefix: @"${attribute.name}NS"];
    }
#if DEBUG_ENUNCIATE > 1
    else {
      NSLog(@"No attempt will be made to write xmlns attribute for QName because either it's the empty namespace, or the prefix is already defined, implying that the xmlns attribute is already written.");
    }
#endif
      [/#if]

    status = xmlTextWriterStartAttributeNS(writer, [#if ((attribute.namespace??) && (attribute.namespace != ""))]BAD_CAST "${prefix(attribute.namespace)}"[#else]NULL[/#if], BAD_CAST "${attribute.name}", NULL);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing start attribute {${attribute.namespace!""}}${attribute.name}."];
    }

#if DEBUG_ENUNCIATE > 1
    NSLog(@"writing attribute {${attribute.namespace!""}}${attribute.name}...");
#endif
    [#if functionIdentifierFor(attribute)??]
    status = xmlTextWriterWrite${functionIdentifierFor(attribute)?cap_first}Type(writer, [#if attribute.accessorType.primitive]&_${clientSimpleName(attribute)}[#else][self ${clientSimpleName(attribute)}][/#if]);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing attribute {${attribute.namespace!""}}${attribute.name}."];
    }
    [#else]
    [[self ${clientSimpleName(attribute)}] writeXMLType: writer];
    [/#if]
#if DEBUG_ENUNCIATE > 1
    NSLog(@"successfully wrote attribute {${attribute.namespace!""}}${attribute.name}...");
#endif

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing end attribute {${attribute.namespace!""}}${attribute.name}."];
    }
  }
    [/#if]
  [/#if]
[/#list]
[#if type.hasAnyAttribute]
  if ([self otherAttributes]) {
    __enumerator = [[self otherAttributes] objectEnumerator];

    while ( (__node = (JAXBBasicXMLNode *) [__enumerator nextObject]) ) {
      status = xmlTextWriterWriteAttributeNS(writer, BAD_CAST [[__node prefix] UTF8String], BAD_CAST [[__node name] UTF8String], BAD_CAST [[__node ns] UTF8String], BAD_CAST [[__node value] UTF8String]);
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing unknown attribute."];
      }

    }
  }
[/#if]
}

[#if type.value??]
  [#if !isFacetExcluded(type.value)]
//documentation inherited.
- (void) writeJAXBValue: (xmlTextWriterPtr) writer
{
#if DEBUG_ENUNCIATE > 1
  NSLog(@"writing element value...");
#endif
    [#if functionIdentifierFor(type.value)??]
  if (xmlTextWriterWrite${functionIdentifierFor(type.value)?cap_first}Type(writer, [#if type.value.accessorType.primitive]&_${clientSimpleName(type.value)}[#else][self ${clientSimpleName(type.value)}][/#if]) < 0) {
    [NSException raise: @"XMLWriteError"
                 format: @"Error writing element value."];
  }
    [#else]
      [#if type.value.QNameType!false]
    if (([[[self ${clientSimpleName(type.value)}] prefix] length] == 0) &&
       ([[[self ${clientSimpleName(type.value)}] namespaceURI] length] > 0)) {
      status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:valueNS", BAD_CAST [[[self ${clientSimpleName(type.value)}] namespaceURI] UTF8String]);
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing namespace attribute xmlns:valueNS."];
      }

      [[self ${clientSimpleName(attribute)}] setPrefix: @"valueNS"];
    }
#if DEBUG_ENUNCIATE > 1
    else {
      NSLog(@"No attempt will be made to write xmlns attribute for QName because either it's the empty namespace, or the prefix is already defined, implying that the xmlns attribute is already written.");
    }
#endif
      [/#if]
  [[self ${clientSimpleName(type.value)}] writeXMLType: writer];
    [/#if]
#if DEBUG_ENUNCIATE > 1
  NSLog(@"successfully wrote element value...");
#endif
}
  [/#if]

/**
 * Method for writing the child elements.
 *
 * @param writer The writer.
 */
- (void) writeJAXBChildElements: (xmlTextWriterPtr) writer
{
  [super writeJAXBChildElements: writer];
}
[#else]
//documentation inherited.
- (void) writeJAXBValue: (xmlTextWriterPtr) writer
{
  [super writeJAXBValue: writer];
}

/**
 * Method for writing the child elements.
 *
 * @param writer The writer.
 */
- (void) writeJAXBChildElements: (xmlTextWriterPtr) writer
{
  int status;
  id __item;
  id __item_copy;
  NSEnumerator *__enumerator;

  [super writeJAXBChildElements: writer];

  [#list type.elements as element]
    [#if !isFacetExcluded(element)]
      [#if !accessorOverridesAnother(element)]
        [#if functionIdentifierFor(element)??]
          [#if element.accessorType.primitive]
  if (YES) { //always write the primitive element...
          [#else]
  if ([self ${clientSimpleName(element)}] != NULL) {
          [/#if]
    status = xmlTextWriterStartElementNS(writer, [#if ((element.namespace??) && (element.namespace != ""))]BAD_CAST "${prefix(element.namespace)}"[#else]NULL[/#if], BAD_CAST "${element.name}", NULL);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing start child element {${element.namespace!""}}${element.name}."];
    }

#if DEBUG_ENUNCIATE > 1
    NSLog(@"writing element {${element.namespace!""}}${element.name}...");
#endif
    status = xmlTextWriterWrite${functionIdentifierFor(element)?cap_first}Type(writer, [#if element.accessorType.primitive]&_${clientSimpleName(element)}[#else][self ${clientSimpleName(element)}][/#if]);
#if DEBUG_ENUNCIATE > 1
    NSLog(@"successfully wrote element {${element.namespace!""}}${element.name}...");
#endif
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing child element {${element.namespace!""}}${element.name}."];
    }

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing end child element {${element.namespace!""}}${element.name}."];
    }
  }
        [#else]
  if ([self ${clientSimpleName(element)}]) {
          [#if element.wrapped]
    status = xmlTextWriterStartElementNS(writer, [#if ((element.wrapperNamespace??) && (element.wrapperNamespace != ""))]BAD_CAST "${prefix(element.wrapperNamespace)}"[#else]NULL[/#if], BAD_CAST "${element.wrapperName}", NULL);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing start wrapper element {${element.wrapperNamespace!""}}${element.wrapperName}."];
    }
          [/#if]
          [#if element.collectionType || element.choices?size > 1]
            [#if element.collectionType]
    __enumerator = [[self ${clientSimpleName(element)}] objectEnumerator];

    while ( (__item = [__enumerator nextObject]) ) {
            [#else]
    __item = [self ${clientSimpleName(element)}];
            [/#if]
            [#if element.elementRefs!false]
      [__item writeXMLElement: writer writeNamespaces: NO];
            [#elseif element.choices?size > 1]
              [#list element.choices as choice]
      if ([__item isMemberOfClass: [${classnameFor(choice)} class]] == YES) {
        status = xmlTextWriterStartElementNS(writer, [#if ((choice.namespace??) && (choice.namespace != ""))]BAD_CAST "${prefix(choice.namespace)}"[#else]NULL[/#if], BAD_CAST "${choice.name}", NULL);
        if (status < 0) {
          [NSException raise: @"XMLWriteError"
                       format: @"Error writing start child element {${choice.namespace!""}}${choice.name}."];
        }

#if DEBUG_ENUNCIATE > 1
        NSLog(@"writing element choice {${choice.namespace!""}}${choice.name}...");
#endif
                [#if functionIdentifierFor(choice)??]
        status = xmlTextWriterWrite${functionIdentifierFor(choice)?cap_first}Type(writer, ((${classnameFor(choice)}*) [((NSValue *)__item) pointerValue]));
        if (status < 0) {
          [NSException raise: @"XMLWriteError"
                       format: @"Error writing child element {${choice.namespace!""}}${choice.name}."];
        }
                [#else]
                  [#if choice.QNameType!false]
        if (([[__item prefix] length] == 0) &&
           ([[__item namespaceURI] length] > 0)) {
          status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:${choice.name}NS", BAD_CAST [[__item namespaceURI] UTF8String]);
          if (status < 0) {
            [NSException raise: @"XMLWriteError"
                         format: @"Error writing namespace attribute xmlns:${choice.name}NS."];
          }

          [__item setPrefix: @"${choice.name}NS"];
        }
#if DEBUG_ENUNCIATE > 1
        else {
          NSLog(@"No attempt will be made to write xmlns attribute for QName because either it's the empty namespace, or the prefix is already defined, implying that the xmlns attribute is already written.");
        }
#endif
                  [/#if]
        [__item writeXMLType: writer];
                [/#if]
#if DEBUG_ENUNCIATE > 1
        NSLog(@"successfully wrote element choice {${choice.namespace!""}}${choice.name}...");
#endif

        status = xmlTextWriterEndElement(writer);
        if (status < 0) {
          [NSException raise: @"XMLWriteError"
                       format: @"Error writing end child element {${choice.namespace!""}}${choice.name}."];
        }
        continue;
      }
              [/#list]
            [#else]
      status = xmlTextWriterStartElementNS(writer, [#if ((element.namespace??) && (element.namespace != ""))]BAD_CAST "${prefix(element.namespace)}"[#else]NULL[/#if], BAD_CAST "${element.name}", NULL);
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing start child element {${element.namespace!""}}${element.name}."];
      }

#if DEBUG_ENUNCIATE > 1
      NSLog(@"writing element {${element.namespace!""}}${element.name}...");
#endif
              [#if functionIdentifierFor(element.collectionItemType)??]
                [#if element.collectionType && element.collectionItemType.enum!false]
                [#--special case for arrays of enums (see http://jira.codehaus.org/browse/ENUNCIATE-766)--]
      __item_copy = malloc(sizeof(${classnameFor(element.collectionItemType)}));
      [((NSValue *)__item) getValue:__item_copy];
      status = xmlTextWriterWrite${functionIdentifierFor(element.collectionItemType)?cap_first}Type(writer, ((${classnameFor(element.collectionItemType)}*) __item_copy));
      free(__item_copy);
                [#else]
      status = xmlTextWriterWrite${functionIdentifierFor(element.collectionItemType)?cap_first}Type(writer, ((${classnameFor(element.collectionItemType)}*) [((NSValue *)__item) pointerValue]));
                [/#if]
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing child element {${element.namespace!""}}${element.name}."];
      }
              [#else]
                [#if element.QNameType!false]
      if (([[__item prefix] length] == 0) &&
         ([[__item namespaceURI] length] > 0)) {
        status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:${element.name}NS", BAD_CAST [[__item namespaceURI] UTF8String]);
        if (status < 0) {
          [NSException raise: @"XMLWriteError"
                       format: @"Error writing namespace attribute xmlns:${element.name}NS."];
        }

        [__item setPrefix: @"${element.name}NS"];
      }
#if DEBUG_ENUNCIATE > 1
      else {
        NSLog(@"No attempt will be made to write xmlns attribute for QName because either it's the empty namespace, or the prefix is already defined, implying that the xmlns attribute is already written.");
      }
#endif
                [/#if]
      [__item writeXMLType: writer];
              [/#if]
#if DEBUG_ENUNCIATE > 1
      NSLog(@"successfully wrote element {${element.namespace!""}}${element.name}...");
#endif

      status = xmlTextWriterEndElement(writer);
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing end child element {${element.namespace!""}}${element.name}."];
      }
            [/#if]
            [#if element.collectionType]
    } //end item iterator.
            [/#if]
          [#elseif element.ref??]
    [[self ${clientSimpleName(element)}] writeXMLElement: writer writeNamespaces: NO];
          [#else]
    status = xmlTextWriterStartElementNS(writer, [#if ((element.namespace??) && (element.namespace != ""))]BAD_CAST "${prefix(element.namespace)}"[#else]NULL[/#if], BAD_CAST "${element.name}", NULL);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing start child element {${element.namespace!""}}${element.name}."];
    }

#if DEBUG_ENUNCIATE > 1
    NSLog(@"writing element {${element.namespace!""}}${element.name}...");
#endif
            [#if element.QNameType!false]
    if (([[[self ${clientSimpleName(element)}] prefix] length] == 0) &&
       ([[[self ${clientSimpleName(element)}] namespaceURI] length] > 0)) {
      status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:${element.name}NS", BAD_CAST [[[self ${clientSimpleName(element)}] namespaceURI] UTF8String]);
      if (status < 0) {
        [NSException raise: @"XMLWriteError"
                     format: @"Error writing namespace attribute xmlns:${element.name}NS."];
      }

      [[self ${clientSimpleName(element)}] setPrefix: @"${element.name}NS"];
    }
#if DEBUG_ENUNCIATE > 1
    else {
      NSLog(@"No attempt will be made to write xmlns attribute for QName because either it's the empty namespace, or the prefix is already defined, implying that the xmlns attribute is already written.");
    }
#endif
            [/#if]
    [[self ${clientSimpleName(element)}] writeXMLType: writer];
#if DEBUG_ENUNCIATE > 1
    NSLog(@"successfully wrote element {${element.namespace!""}}${element.name}...");
#endif

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing end child element {${element.namespace!""}}${element.name}."];
    }
          [/#if]
          [#if element.wrapped]

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
      [NSException raise: @"XMLWriteError"
                   format: @"Error writing end wrapper element {${element.wrapperNamespace!""}}${element.wrapperName}."];
    }
          [/#if]
  }
        [/#if]
        [#if type.anyElement??]

  if ([self ${clientSimpleName(type.anyElement)}]) {
    __enumerator = [[self ${clientSimpleName(type.anyElement)}] objectEnumerator];

    while ( (__item = [__enumerator nextObject]) ) {
      [__item writeXMLElement: writer writeNamespaces: NO];
    }
  }
        [/#if]
      [/#if]
    [/#if]
  [/#list]
}
[/#if]
@end /* implementation ${typeName} (JAXB) */

#endif /* DEF_${typeName}_M */
[/#macro]
